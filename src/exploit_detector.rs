// Advanced Shellcode and Exploit Detection
use std::collections::HashMap;

/// Shellcode and exploit detector
pub struct ExploitDetector {
    shellcode_patterns: Vec<ShellcodePattern>,
    rop_gadgets: Vec<ROPGadget>,
    exploit_signatures: Vec<ExploitSignature>,
}

#[derive(Debug, Clone)]
pub struct ShellcodePattern {
    pub name: String,
    pub bytes: Vec<u8>,
    pub mask: Vec<u8>, // 0xFF = exact match, 0x00 = wildcard
    pub description: String,
    pub severity: ExploitSeverity,
}

#[derive(Debug, Clone)]
pub struct ROPGadget {
    pub bytes: Vec<u8>,
    pub description: String,
    pub useful_for: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct ExploitSignature {
    pub name: String,
    pub patterns: Vec<Vec<u8>>,
    pub description: String,
    pub cve_refs: Vec<String>,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ExploitSeverity {
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Clone)]
pub struct ExploitDetectionResult {
    pub shellcodes_found: Vec<DetectedShellcode>,
    pub rop_gadgets_found: Vec<DetectedGadget>,
    pub exploits_found: Vec<DetectedExploit>,
    pub obfuscation_detected: bool,
    pub risk_score: f64,
}

#[derive(Debug, Clone)]
pub struct DetectedShellcode {
    pub pattern: String,
    pub offset: usize,
    pub severity: ExploitSeverity,
    pub description: String,
}

#[derive(Debug, Clone)]
pub struct DetectedGadget {
    pub gadget: String,
    pub offset: usize,
    pub useful_for: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct DetectedExploit {
    pub name: String,
    pub offset: usize,
    pub cve_refs: Vec<String>,
}

impl ExploitDetector {
    pub fn new() -> Self {
        Self {
            shellcode_patterns: Self::get_shellcode_patterns(),
            rop_gadgets: Self::get_rop_gadgets(),
            exploit_signatures: Self::get_exploit_signatures(),
        }
    }

    fn get_shellcode_patterns() -> Vec<ShellcodePattern> {
        vec![
            // x86_64 execve("/bin/sh") shellcode
            ShellcodePattern {
                name: "execve_binsh_x64".to_string(),
                bytes: vec![0x48, 0x31, 0xd2, 0x48, 0xbb, 0x2f, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68],
                mask: vec![0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF],
                description: "x86_64 execve /bin/sh shellcode".to_string(),
                severity: ExploitSeverity::Critical,
            },
            // NOP sled detection
            ShellcodePattern {
                name: "nop_sled".to_string(),
                bytes: vec![0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90],
                mask: vec![0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF],
                description: "NOP sled (potential shellcode preparation)".to_string(),
                severity: ExploitSeverity::Medium,
            },
            // Egg hunter pattern
            ShellcodePattern {
                name: "egg_hunter".to_string(),
                bytes: vec![0x66, 0x81, 0x3f], // cmp word ptr [edi], tag
                mask: vec![0xFF, 0xFF, 0xFF],
                description: "Egg hunter shellcode pattern".to_string(),
                severity: ExploitSeverity::High,
            },
            // Polymorphic decoder stub
            ShellcodePattern {
                name: "poly_decoder".to_string(),
                bytes: vec![0xeb, 0x00, 0x5e, 0x31, 0xc9], // jmp +2, pop esi, xor ecx,ecx
                mask: vec![0xFF, 0x00, 0xFF, 0xFF, 0xFF],
                description: "Polymorphic decoder stub".to_string(),
                severity: ExploitSeverity::High,
            },
        ]
    }

    fn get_rop_gadgets() -> Vec<ROPGadget> {
        vec![
            ROPGadget {
                bytes: vec![0x58, 0xc3], // pop rax; ret
                description: "pop rax; ret".to_string(),
                useful_for: vec!["syscall number setup".to_string()],
            },
            ROPGadget {
                bytes: vec![0x5f, 0xc3], // pop rdi; ret
                description: "pop rdi; ret".to_string(),
                useful_for: vec!["first argument setup".to_string()],
            },
            ROPGadget {
                bytes: vec![0x5e, 0xc3], // pop rsi; ret
                description: "pop rsi; ret".to_string(),
                useful_for: vec!["second argument setup".to_string()],
            },
            ROPGadget {
                bytes: vec![0x0f, 0x05, 0xc3], // syscall; ret
                description: "syscall; ret".to_string(),
                useful_for: vec!["syscall execution".to_string()],
            },
        ]
    }

    fn get_exploit_signatures() -> Vec<ExploitSignature> {
        vec![
            ExploitSignature {
                name: "format_string_exploit".to_string(),
                patterns: vec![
                    b"%n%n%n%n".to_vec(),
                    b"%08x.%08x.%08x.%08x".to_vec(),
                ],
                description: "Format string exploit patterns".to_string(),
                cve_refs: vec!["CVE-2000-0573".to_string()],
            },
            ExploitSignature {
                name: "buffer_overflow_pattern".to_string(),
                patterns: vec![
                    vec![0x41; 100], // 100 'A's
                    vec![0x42; 200], // 200 'B's
                ],
                description: "Buffer overflow test patterns".to_string(),
                cve_refs: vec![],
            },
        ]
    }

    /// Detect shellcode and exploits in binary
    pub fn detect_exploits(&self, binary_data: &[u8]) -> ExploitDetectionResult {
        let mut result = ExploitDetectionResult {
            shellcodes_found: Vec::new(),
            rop_gadgets_found: Vec::new(),
            exploits_found: Vec::new(),
            obfuscation_detected: false,
            risk_score: 0.0,
        };

        // Detect shellcode patterns
        result.shellcodes_found = self.detect_shellcode_patterns(binary_data);

        // Detect ROP gadgets
        result.rop_gadgets_found = self.detect_rop_gadgets(binary_data);

        // Detect known exploits
        result.exploits_found = self.detect_exploit_signatures(binary_data);

        // Detect obfuscation
        result.obfuscation_detected = self.detect_obfuscation(binary_data);

        // Calculate risk score
        result.risk_score = self.calculate_exploit_risk(&result);

        result
    }

    fn detect_shellcode_patterns(&self, data: &[u8]) -> Vec<DetectedShellcode> {
        let mut detected = Vec::new();

        for pattern in &self.shellcode_patterns {
            let matches = self.find_pattern_with_mask(data, &pattern.bytes, &pattern.mask);
            for offset in matches {
                detected.push(DetectedShellcode {
                    pattern: pattern.name.clone(),
                    offset,
                    severity: pattern.severity.clone(),
                    description: pattern.description.clone(),
                });
            }
        }

        detected
    }

    fn detect_rop_gadgets(&self, data: &[u8]) -> Vec<DetectedGadget> {
        let mut detected = Vec::new();

        for gadget in &self.rop_gadgets {
            let matches = self.find_exact_pattern(data, &gadget.bytes);
            for offset in matches {
                detected.push(DetectedGadget {
                    gadget: gadget.description.clone(),
                    offset,
                    useful_for: gadget.useful_for.clone(),
                });
            }
        }

        detected
    }

    fn detect_exploit_signatures(&self, data: &[u8]) -> Vec<DetectedExploit> {
        let mut detected = Vec::new();

        for signature in &self.exploit_signatures {
            for pattern in &signature.patterns {
                let matches = self.find_exact_pattern(data, pattern);
                for offset in matches {
                    detected.push(DetectedExploit {
                        name: signature.name.clone(),
                        offset,
                        cve_refs: signature.cve_refs.clone(),
                    });
                }
            }
        }

        detected
    }

    fn detect_obfuscation(&self, data: &[u8]) -> bool {
        // Check for high entropy (possible encryption/packing)
        let entropy = self.calculate_entropy(data);
        if entropy > 7.5 {
            return true;
        }

        // Check for suspicious patterns
        let suspicious_patterns = [
            vec![0xcc, 0xcc, 0xcc, 0xcc], // int3 padding
            vec![0x00, 0x00, 0x00, 0x00], // null padding
        ];

        for pattern in &suspicious_patterns {
            if self.find_exact_pattern(data, pattern).len() > 10 {
                return true;
            }
        }

        false
    }

    fn find_pattern_with_mask(&self, data: &[u8], pattern: &[u8], mask: &[u8]) -> Vec<usize> {
        let mut matches = Vec::new();

        for i in 0..=data.len().saturating_sub(pattern.len()) {
            let mut match_found = true;
            for j in 0..pattern.len() {
                if mask[j] == 0xFF && data[i + j] != pattern[j] {
                    match_found = false;
                    break;
                }
            }
            if match_found {
                matches.push(i);
            }
        }

        matches
    }

    fn find_exact_pattern(&self, data: &[u8], pattern: &[u8]) -> Vec<usize> {
        data.windows(pattern.len())
            .enumerate()
            .filter_map(|(i, window)| {
                if window == pattern {
                    Some(i)
                } else {
                    None
                }
            })
            .collect()
    }

    fn calculate_entropy(&self, data: &[u8]) -> f64 {
        let mut freq = [0u32; 256];
        for &byte in data {
            freq[byte as usize] += 1;
        }

        let len = data.len() as f64;
        let mut entropy = 0.0;

        for &count in &freq {
            if count > 0 {
                let p = count as f64 / len;
                entropy -= p * p.log2();
            }
        }

        entropy
    }

    fn calculate_exploit_risk(&self, result: &ExploitDetectionResult) -> f64 {
        let mut risk = 0.0;

        // Shellcode risk
        for shellcode in &result.shellcodes_found {
            risk += match shellcode.severity {
                ExploitSeverity::Critical => 0.4,
                ExploitSeverity::High => 0.3,
                ExploitSeverity::Medium => 0.2,
                ExploitSeverity::Low => 0.1,
            };
        }

        // ROP gadget risk
        risk += result.rop_gadgets_found.len() as f64 * 0.1;

        // Known exploit risk
        risk += result.exploits_found.len() as f64 * 0.3;

        // Obfuscation risk
        if result.obfuscation_detected {
            risk += 0.2;
        }

        risk.min(1.0)
    }

    /// Generate detailed exploit report
    pub fn generate_exploit_report(&self, result: &ExploitDetectionResult) -> String {
        let mut report = String::new();

        report.push_str("EXPLOIT DETECTION REPORT\n");
        report.push_str("========================\n\n");

        report.push_str(&format!("Risk Score: {:.2}\n", result.risk_score));
        report.push_str(&format!("Obfuscation Detected: {}\n\n", result.obfuscation_detected));

        if !result.shellcodes_found.is_empty() {
            report.push_str("SHELLCODE PATTERNS DETECTED:\n");
            for shellcode in &result.shellcodes_found {
                report.push_str(&format!(
                    "  - {} at offset 0x{:x} ({})\n",
                    shellcode.pattern, shellcode.offset, shellcode.description
                ));
            }
            report.push_str("\n");
        }

        if !result.rop_gadgets_found.is_empty() {
            report.push_str("ROP GADGETS DETECTED:\n");
            for gadget in &result.rop_gadgets_found {
                report.push_str(&format!(
                    "  - {} at offset 0x{:x}\n",
                    gadget.gadget, gadget.offset
                ));
            }
            report.push_str("\n");
        }

        if !result.exploits_found.is_empty() {
            report.push_str("KNOWN EXPLOITS DETECTED:\n");
            for exploit in &result.exploits_found {
                report.push_str(&format!(
                    "  - {} at offset 0x{:x}\n",
                    exploit.name, exploit.offset
                ));
            }
        }

        report
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_shellcode_detection() {
        let detector = ExploitDetector::new();

        // Test with NOP sled
        let nop_sled = vec![0x90; 16];
        let result = detector.detect_exploits(&nop_sled);

        assert!(!result.shellcodes_found.is_empty());
        assert!(result.risk_score > 0.0);
    }

    #[test]
    fn test_rop_gadget_detection() {
        let detector = ExploitDetector::new();

        // Test with pop rax; ret gadget
        let gadget_bytes = vec![0x58, 0xc3];
        let result = detector.detect_exploits(&gadget_bytes);

        assert!(!result.rop_gadgets_found.is_empty());
    }

    #[test]
    fn test_entropy_calculation() {
        let detector = ExploitDetector::new();

        // High entropy data (random)
        let high_entropy = (0..256).map(|i| i as u8).collect::<Vec<_>>();
        assert!(detector.calculate_entropy(&high_entropy) > 7.0);

        // Low entropy data (repeated)
        let low_entropy = vec![0x41; 256];
        assert!(detector.calculate_entropy(&low_entropy) < 1.0);
    }
}
