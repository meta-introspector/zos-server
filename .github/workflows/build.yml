name: Build Matrix with Tracing

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  ACTIONS_ORG: meta-introspector
  RUST_ORG: meta-introspector
  CACHE_ORG: meta-introspector
  RUST_BACKTRACE: 1

jobs:
  matrix-build:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        features:
          - "default"
          - "all-plugins"
          - "self-build"
        target:
          - "x86_64-unknown-linux-gnu"
        profile:
          - "dev"
          - "release"

    steps:
    - uses: actions/checkout@v4
    - uses: dtolnay/rust-toolchain@stable
      with:
        components: rustfmt, clippy
        targets: ${{ matrix.target }}
    - uses: ${{ env.CACHE_ORG }}/rust-cache@v2

    - name: Generate Lattice ID
      id: lattice
      run: |
        # Generate canonical lattice ID based on matrix parameters
        FEATURE_HASH=$(echo "${{ matrix.features }}" | sha256sum | cut -c1-8)
        TARGET_HASH=$(echo "${{ matrix.target }}" | sha256sum | cut -c1-8)
        PROFILE_HASH=$(echo "${{ matrix.profile }}" | sha256sum | cut -c1-8)
        TRACE_HASH=$(echo "${{ matrix.trace }}" | sha256sum | cut -c1-8)

        # Create lattice coordinate system: L[level].[weight].[character].[orbit]
        LEVEL=$((16#$FEATURE_HASH % 100 + 1))  # Level 1-100
        WEIGHT=$((16#$TARGET_HASH % 10 + 1))   # Weight 1-10
        CHARACTER=$((16#$PROFILE_HASH % 5))    # Character 0-4
        ORBIT=$((16#$TRACE_HASH % 20 + 1))     # Orbit 1-20

        LATTICE_ID="L${LEVEL}.${WEIGHT}.${CHARACTER}.${ORBIT}"
        echo "lattice_id=$LATTICE_ID" >> $GITHUB_OUTPUT
        echo "ðŸ”¢ Lattice ID: $LATTICE_ID"

        # Create bucket structure
        BUCKET_PATH="logs/lattice-${LATTICE_ID}"
        echo "bucket_path=$BUCKET_PATH" >> $GITHUB_OUTPUT
        mkdir -p "$BUCKET_PATH"

        # Log matrix configuration
        cat > "$BUCKET_PATH/matrix-config.json" << EOF
        {
          "lattice_id": "$LATTICE_ID",
          "features": "${{ matrix.features }}",
          "target": "${{ matrix.target }}",
          "profile": "${{ matrix.profile }}",
          "trace": "${{ matrix.trace }}",
          "timestamp": "$(date -Iseconds)",
          "github_run_id": "${{ github.run_id }}",
          "github_run_number": "${{ github.run_number }}",
          "github_sha": "${{ github.sha }}",
          "coordinates": {
            "level": $LEVEL,
            "weight": $WEIGHT,
            "character": $CHARACTER,
            "orbit": $ORBIT
          }
        }
        EOF

    - name: Install tracing tools
      run: |
        sudo apt-get update
        sudo apt-get install -y strace perf linux-tools-generic gdb jq
        cargo install cargo-llvm-cov grcov

    - name: Extract compile metadata
      run: |
        BUCKET="${{ steps.lattice.outputs.bucket_path }}"

        # Extract all feature flags
        grep -r "cfg(feature" src/ > "$BUCKET/feature-flags.txt" || true
        # Extract enum definitions
        grep -r "enum " src/ > "$BUCKET/enums.txt" || true
        # Extract compile-time options
        grep -r "#\[cfg" src/ > "$BUCKET/cfg-options.txt" || true

        # Compiler metadata
        rustc --version --verbose > "$BUCKET/rustc-info.txt"
        cargo --version --verbose > "$BUCKET/cargo-info.txt"
        rustc --print target-list | grep ${{ matrix.target }} > "$BUCKET/target-info.txt"

    - name: Build with detailed tracing
      run: |
        BUCKET="${{ steps.lattice.outputs.bucket_path }}"
        LATTICE_ID="${{ steps.lattice.outputs.lattice_id }}"

        echo "ðŸ—ï¸ Building lattice $LATTICE_ID: ${{ matrix.features }}+${{ matrix.target }}+${{ matrix.profile }}+${{ matrix.trace }}"

        # Create detailed build log
        BUILD_LOG="$BUCKET/build-detailed.log"

        case "${{ matrix.trace }}" in
          "strace")
            echo "ðŸ“Š Running strace build for $LATTICE_ID" | tee -a "$BUILD_LOG"
            strace -o "$BUCKET/strace.log" -f -e trace=all \
              cargo build --target ${{ matrix.target }} --features ${{ matrix.features }} \
              $([ "${{ matrix.profile }}" = "release" ] && echo "--release") 2>&1 | \
              tee -a "$BUILD_LOG"
            ;;
          "perf")
            echo "ðŸ“Š Running perf build for $LATTICE_ID" | tee -a "$BUILD_LOG"
            perf record -g -o "$BUCKET/perf.data" \
              cargo build --target ${{ matrix.target }} --features ${{ matrix.features }} \
              $([ "${{ matrix.profile }}" = "release" ] && echo "--release") 2>&1 | \
              tee -a "$BUILD_LOG"
            perf report --input="$BUCKET/perf.data" > "$BUCKET/perf-report.txt" || true
            ;;
          "self-trace")
            echo "ðŸ“Š Running self-trace build for $LATTICE_ID" | tee -a "$BUILD_LOG"
            RUST_LOG=trace cargo build --target ${{ matrix.target }} --features ${{ matrix.features }} \
              $([ "${{ matrix.profile }}" = "release" ] && echo "--release") 2>&1 | \
              tee -a "$BUILD_LOG"
            ;;
          "full-coverage")
            echo "ðŸ“Š Running full-coverage build for $LATTICE_ID" | tee -a "$BUILD_LOG"
            RUSTFLAGS="-C instrument-coverage" \
            cargo build --target ${{ matrix.target }} --features ${{ matrix.features }} \
              $([ "${{ matrix.profile }}" = "release" ] && echo "--release") 2>&1 | \
              tee -a "$BUILD_LOG"
            ;;
        esac

        # Capture build result
        BUILD_RESULT=$?
        echo "build_result=$BUILD_RESULT" >> "$BUCKET/build-status.txt"
        echo "lattice_id=$LATTICE_ID" >> "$BUCKET/build-status.txt"
        echo "timestamp=$(date -Iseconds)" >> "$BUCKET/build-status.txt"

    - name: Extract MIR and HIR
      if: matrix.trace == 'full-coverage'
      run: |
        BUCKET="${{ steps.lattice.outputs.bucket_path }}"
        LATTICE_ID="${{ steps.lattice.outputs.lattice_id }}"

        echo "ðŸ”¬ Extracting MIR/HIR for lattice $LATTICE_ID"

        # Extract MIR
        mkdir -p "$BUCKET/mir"
        RUSTFLAGS="-Z dump-mir=all -Z dump-mir-dir=$BUCKET/mir" \
          cargo +nightly build --target ${{ matrix.target }} --features ${{ matrix.features }} \
          $([ "${{ matrix.profile }}" = "release" ] && echo "--release") || true

        # Extract HIR
        mkdir -p "$BUCKET/hir"
        RUSTFLAGS="-Z unpretty=hir -Z dump-hir-dir=$BUCKET/hir" \
          cargo +nightly build --target ${{ matrix.target }} --features ${{ matrix.features }} \
          $([ "${{ matrix.profile }}" = "release" ] && echo "--release") || true

    - name: Generate coverage and analysis
      if: matrix.trace == 'full-coverage'
      run: |
        BUCKET="${{ steps.lattice.outputs.bucket_path }}"
        LATTICE_ID="${{ steps.lattice.outputs.lattice_id }}"

        echo "ðŸ“ˆ Generating coverage for lattice $LATTICE_ID"

        # Generate coverage report
        cargo llvm-cov --features ${{ matrix.features }} --lcov --output-path "$BUCKET/coverage.lcov" || true

        # Generate analysis summary
        cat > "$BUCKET/analysis-summary.json" << EOF
        {
          "lattice_id": "$LATTICE_ID",
          "analysis_type": "full-coverage",
          "mir_files": $(find "$BUCKET/mir" -name "*.mir" 2>/dev/null | wc -l || echo 0),
          "hir_files": $(find "$BUCKET/hir" -name "*.hir" 2>/dev/null | wc -l || echo 0),
          "coverage_lines": $(wc -l < "$BUCKET/coverage.lcov" 2>/dev/null || echo 0),
          "timestamp": "$(date -Iseconds)"
        }
        EOF

    - name: Create lattice manifest
      run: |
        BUCKET="${{ steps.lattice.outputs.bucket_path }}"
        LATTICE_ID="${{ steps.lattice.outputs.lattice_id }}"

        # Create comprehensive manifest
        cat > "$BUCKET/lattice-manifest.json" << EOF
        {
          "lattice_id": "$LATTICE_ID",
          "coordinates": {
            "level": $(jq -r '.coordinates.level' "$BUCKET/matrix-config.json"),
            "weight": $(jq -r '.coordinates.weight' "$BUCKET/matrix-config.json"),
            "character": $(jq -r '.coordinates.character' "$BUCKET/matrix-config.json"),
            "orbit": $(jq -r '.coordinates.orbit' "$BUCKET/matrix-config.json")
          },
          "matrix": {
            "features": "${{ matrix.features }}",
            "target": "${{ matrix.target }}",
            "profile": "${{ matrix.profile }}",
            "trace": "${{ matrix.trace }}"
          },
          "files": {
            "logs": [
              $(find "$BUCKET" -name "*.log" -printf '"%f",' | sed 's/,$//')
            ],
            "data": [
              $(find "$BUCKET" -name "*.data" -printf '"%f",' | sed 's/,$//')
            ],
            "reports": [
              $(find "$BUCKET" -name "*report*" -printf '"%f",' | sed 's/,$//')
            ],
            "coverage": [
              $(find "$BUCKET" -name "*.lcov" -printf '"%f",' | sed 's/,$//')
            ]
          },
          "metadata": {
            "github_run_id": "${{ github.run_id }}",
            "github_sha": "${{ github.sha }}",
            "timestamp": "$(date -Iseconds)",
            "size_bytes": $(du -sb "$BUCKET" | cut -f1)
          }
        }
        EOF

        echo "ðŸ“¦ Lattice $LATTICE_ID manifest created"

    - name: Upload lattice bucket
      uses: ${{ env.ACTIONS_ORG }}/upload-artifact@v4
      with:
        name: lattice-${{ steps.lattice.outputs.lattice_id }}
        path: ${{ steps.lattice.outputs.bucket_path }}
        retention-days: 30

  collect-lattices:
    runs-on: ubuntu-latest
    needs: matrix-build
    steps:
    - uses: ${{ env.ACTIONS_ORG }}/checkout@v4
    - uses: ${{ env.ACTIONS_ORG }}/download-artifact@v4
      with:
        path: all-lattices/

    - name: Generate lattice index
      run: |
        mkdir -p lattice-index

        # Create master index of all lattices
        echo "# ZOS Server Build Lattice Index" > lattice-index/README.md
        echo "Generated: $(date -Iseconds)" >> lattice-index/README.md
        echo "" >> lattice-index/README.md

        # Collect all lattice manifests
        LATTICES_JSON="["
        FIRST=true

        for lattice_dir in all-lattices/lattice-L*; do
          if [ -d "$lattice_dir" ] && [ -f "$lattice_dir/lattice-manifest.json" ]; then
            LATTICE_ID=$(basename "$lattice_dir" | sed 's/lattice-//')

            if [ "$FIRST" = true ]; then
              FIRST=false
            else
              LATTICES_JSON="$LATTICES_JSON,"
            fi

            LATTICES_JSON="$LATTICES_JSON$(cat "$lattice_dir/lattice-manifest.json")"

            # Add to README
            echo "## Lattice $LATTICE_ID" >> lattice-index/README.md
            echo "- Features: $(jq -r '.matrix.features' "$lattice_dir/lattice-manifest.json")" >> lattice-index/README.md
            echo "- Target: $(jq -r '.matrix.target' "$lattice_dir/lattice-manifest.json")" >> lattice-index/README.md
            echo "- Profile: $(jq -r '.matrix.profile' "$lattice_dir/lattice-manifest.json")" >> lattice-index/README.md
            echo "- Trace: $(jq -r '.matrix.trace' "$lattice_dir/lattice-manifest.json")" >> lattice-index/README.md
            echo "- Size: $(jq -r '.metadata.size_bytes' "$lattice_dir/lattice-manifest.json") bytes" >> lattice-index/README.md
            echo "" >> lattice-index/README.md
          fi
        done

        LATTICES_JSON="$LATTICES_JSON]"
        echo "$LATTICES_JSON" > lattice-index/lattices.json

        # Generate statistics
        TOTAL_LATTICES=$(echo "$LATTICES_JSON" | jq length)
        TOTAL_SIZE=$(echo "$LATTICES_JSON" | jq '[.[].metadata.size_bytes] | add')

        cat > lattice-index/statistics.json << EOF
        {
          "total_lattices": $TOTAL_LATTICES,
          "total_size_bytes": $TOTAL_SIZE,
          "generation_time": "$(date -Iseconds)",
          "github_run_id": "${{ github.run_id }}",
          "github_sha": "${{ github.sha }}"
        }
        EOF

        echo "ðŸ“Š Generated index for $TOTAL_LATTICES lattices ($TOTAL_SIZE bytes total)"

    - name: Upload lattice index
      uses: ${{ env.ACTIONS_ORG }}/upload-artifact@v4
      with:
        name: lattice-index
        path: lattice-index/
        retention-days: 90

  docker-build:
    runs-on: ubuntu-latest
    needs: matrix-build
    steps:
    - uses: ${{ env.ACTIONS_ORG }}/checkout@v4
    - name: Build Docker image
      run: docker build -t zos-server:${{ github.sha }} .
    - name: Test Docker image
      run: |
        docker run --rm zos-server:${{ github.sha }} --version || true
